import tkinter as tk
from tkinter import ttk
import random
import time

# --- 1. CORE MDP LOGIC (Defined functions) ---

# MDP Parameters
STATES = [0, 1, 2, 3]
ACTIONS = ['LEFT', 'RIGHT']
GAMMA = 0.9      # Discount Factor (assumed)
EPSILON = 1e-4   # Convergence threshold

V = {s: 0.0 for s in STATES}
V[3] = 0.0

# 1. Transition Model T(s'|s, a)
def transition_prob(s, a, s_prime):
    """Calculates P(s'|s, a)"""
    if s == 3:
        return 1.0 if s_prime == 3 else 0.0
    
    P_move = 0.8
    P_stay = 0.2
    
    if a == 'RIGHT':
        intended_s = min(s + 1, 3)
    elif a == 'LEFT':
        intended_s = max(s - 1, 0)
    else:
        return 0.0

    if intended_s == s:
        # At boundary, both 0.8 and 0.2 result in staying at s
        return 1.0 if s_prime == s else 0.0
    
    if s_prime == intended_s:
        return P_move
    elif s_prime == s:
        return P_stay
    else:
        return 0.0

# 2. Reward Function R(s, a, s')
def reward(s, a, s_prime):
    """Reward function R(s, a, s')"""
    if s_prime == 3:
        return 9.0 # (+10 Goal - 1 Move)
    return -1.0 # Move/Stay cost

# 3. Value Iteration Solver
def value_iteration():
    """Finds the optimal value function V* and policy Pi*."""
    global V
    
    # Reset V for a clean run
    V = {s: 0.0 for s in STATES} 
    V[3] = 0.0
    
    while True:
        delta = 0
        V_new = V.copy()
        
        for s in [0, 1, 2]:
            v_old = V[s]
            q_values = {}
            
            for a in ACTIONS:
                q = 0
                for s_prime in STATES:
                    p = transition_prob(s, a, s_prime)
                    r = reward(s, a, s_prime)
                    q += p * (r + GAMMA * V[s_prime])
                q_values[a] = q
            
            V_new[s] = max(q_values.values())
            delta = max(delta, abs(V_new[s] - v_old))
            
        V = V_new
        if delta < EPSILON:
            break
            
    # Compute Optimal Policy PI*
    policy = {}
    for s in [0, 1, 2]:
        best_q = -float('inf')
        best_a = None
        
        for a in ACTIONS:
            q = sum(transition_prob(s, a, s_prime) * (reward(s, a, s_prime) + GAMMA * V[s_prime]) for s_prime in STATES)
            if q > best_q:
                best_q = q
                best_a = a
        policy[s] = best_a
        
    return V, policy

# --- 2. GUI APPLICATION CLASS ---
class RobotHallwayGUI:
    def __init__(self, master):
        self.master = master
        master.title("Robot in a 1D Hallway (MDP)")
        
        # 1. Run MDP Solver
        self.optimal_V, self.optimal_Pi = value_iteration()
        self.current_state = 0
        self.step_count = 0
        self.is_running = False

        # --- GUI Elements Setup ---
        self.grid_frames = []
        self.info_labels = []
        
        # Hallway Grid Frame (tk.Frame for background coloring)
        # Fix applied here: changed ttk.Frame to tk.Frame
        self.hallway_frame = tk.Frame(master, padx=10, pady=10)
        self.hallway_frame.pack()
        
        # Create 4 cells for the 1D hallway
        for i in range(4):
            # Fix applied here: changed ttk.Frame to tk.Frame
            frame = tk.Frame(self.hallway_frame, borderwidth=2, relief="groove", width=80, height=80)
            frame.grid(row=0, column=i, padx=5, pady=5)
            frame.grid_propagate(False) # Prevent frame from resizing to label content
            
            # Label for State (0, 1, 2, 3)
            state_label = ttk.Label(frame, text=f"State {i}", font=('Arial', 10))
            state_label.pack(pady=2)
            
            # Label for content (Robot/Empty/Goal)
            info_label = ttk.Label(frame, text="", font=('Arial', 18, 'bold'))
            info_label.pack(pady=5)
            
            self.grid_frames.append(frame)
            self.info_labels.append(info_label)

        # Info Panel Frame (tk.Frame for consistent look, though ttk.Frame would be fine here)
        # Fix applied here: changed ttk.Frame to tk.Frame
        self.info_panel = tk.Frame(master, padx=10, pady=10)
        self.info_panel.pack(pady=10)
        
        self.status_var = tk.StringVar(value="Optimal Policy Found! Select Start State.")
        self.status_label = ttk.Label(self.info_panel, textvariable=self.status_var, font=('Arial', 12))
        self.status_label.grid(row=0, column=0, columnspan=2, pady=5)

        self.step_var = tk.StringVar(value="Steps: 0")
        self.step_label = ttk.Label(self.info_panel, textvariable=self.step_var)
        self.step_label.grid(row=1, column=0, padx=10)

        # Start State Selector
        ttk.Label(self.info_panel, text="Start State:").grid(row=2, column=0, padx=10, pady=5, sticky='w')
        self.start_state_var = tk.StringVar(value='0')
        self.start_state_menu = ttk.Combobox(self.info_panel, textvariable=self.start_state_var, values=['0', '1', '2'], width=5)
        self.start_state_menu.grid(row=2, column=1, padx=10, pady=5, sticky='w')
        
        # Control Buttons
        self.reset_button = ttk.Button(self.info_panel, text="Reset/Setup", command=self.reset_simulation)
        self.reset_button.grid(row=3, column=0, padx=10, pady=10)
        
        self.step_button = ttk.Button(self.info_panel, text="Next Step", command=lambda: self.simulate_step(continuous=False), state=tk.DISABLED)
        self.step_button.grid(row=3, column=1, padx=10, pady=10)
        
        self.run_button = ttk.Button(self.info_panel, text="Run (Auto)", command=self.toggle_run, state=tk.DISABLED)
        self.run_button.grid(row=4, column=0, columnspan=2, pady=5)

        # Initialize the visualization
        self.update_visualization()
        self.display_policy_and_values()
        
    def display_policy_and_values(self):
        """Displays the solved policy and values for reference."""
        policy_str = "Optimal Policy (Pi*):\n"
        for s, a in self.optimal_Pi.items():
            policy_str += f"State {s}: {a}\n"
        
        values_str = "\nOptimal Values (V*):\n"
        for s, v in self.optimal_V.items():
            values_str += f"State {s}: {v:.2f}\n"

        # Create a text area for results
        self.results_text = tk.Text(self.master, height=10, width=30, padx=10, pady=10)
        self.results_text.insert(tk.END, policy_str + values_str)
        self.results_text.config(state=tk.DISABLED) # Make it read-only
        self.results_text.pack(pady=10)

    def update_visualization(self):
        """Redraws the hallway grid based on the current state."""
        for i in range(4):
            label = self.info_labels[i]
            frame = self.grid_frames[i]
            
            # Reset colors (SystemButtonFace is a standard tkinter color)
            # This uses the correct background option for tk.Frame
            frame.config(background='SystemButtonFace')
            
            if i == 3:
                label.config(text="âš¡", foreground="green")
                frame.config(background='lightgreen')
            elif i == self.current_state:
                label.config(text="ðŸ¤–", foreground="blue")
                frame.config(background='lightblue')
            else:
                label.config(text="", foreground="black")
                
    def reset_simulation(self):
        """Resets the robot to the selected start state."""
        if self.is_running:
             self.toggle_run() # Stop auto-run if active
             
        try:
            start_s = int(self.start_state_var.get())
        except ValueError:
            start_s = 0
            
        # State 3 is terminal and not a valid starting state for the agent
        if start_s == 3: start_s = 0 

        self.current_state = start_s
        self.step_count = 0
        self.step_var.set(f"Steps: {self.step_count}")
        self.status_var.set(f"Simulation ready. Start State: {start_s}. Policy: {self.optimal_Pi.get(start_s)}")
        self.update_visualization()
        
        # Enable controls for simulation
        self.step_button.config(state=tk.NORMAL)
        self.run_button.config(state=tk.NORMAL)

    def toggle_run(self):
        """Toggles continuous running mode."""
        self.is_running = not self.is_running
        
        if self.is_running:
            self.run_button.config(text="Stop (Auto)")
            self.step_button.config(state=tk.DISABLED)
            self.simulate_step(continuous=True)
        else:
            self.run_button.config(text="Run (Auto)")
            self.step_button.config(state=tk.NORMAL)
        
    def simulate_step(self, continuous=False):
        """Performs a single step of the stochastic simulation."""
        
        if self.current_state == 3:
            self.status_var.set(f"GOAL REACHED in {self.step_count} steps!")
            self.step_button.config(state=tk.DISABLED)
            self.run_button.config(state=tk.DISABLED)
            self.is_running = False
            return
            
        # 1. Agent chooses action based on Optimal Policy (Pi*)
        action = self.optimal_Pi[self.current_state]
        
        # 2. Determine next state based on stochastic Transition Model
        possible_next_states = []
        probabilities = []
        
        for s_prime in STATES:
            p = transition_prob(self.current_state, action, s_prime)
            if p > 0:
                possible_next_states.append(s_prime)
                probabilities.append(p)

        # Randomly sample the next state
        next_s = random.choices(possible_next_states, weights=probabilities, k=1)[0]
        
        # 3. Update state, step count, and display status
        self.status_var.set(f"State {self.current_state} -> Pi* Action: {action} -> Stochastic Result: {next_s}")
        self.current_state = next_s
        self.step_count += 1
        self.step_var.set(f"Steps: {self.step_count}")
        self.update_visualization()
        
        # 4. Continue running if in continuous mode
        if continuous and self.is_running and self.current_state != 3:
            # Schedule the next step after 500ms
            self.master.after(500, lambda: self.simulate_step(continuous=True))


# --- 3. MAIN EXECUTION ---
if __name__ == "__main__":
    # Create the main window
    root = tk.Tk()
    
    # Initialize and run the GUI application
    app = RobotHallwayGUI(root)
    
    # Start the Tkinter event loop
    root.mainloop()